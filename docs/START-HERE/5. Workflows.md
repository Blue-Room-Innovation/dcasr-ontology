Here is the **faithful English translation**, preserving **all content, structure, commands, and intent**:

---

### Workflow 1: Creating a New Ontology and Shapes

1. Create your ontology file: `ontology/v0.1/myNewOntology.ttl`
2. Create the corresponding SHACL shapes: `shapes/v0.1/myNewOntology.shacl.ttl`
3. Validate OWL syntax: `npm run validate:owl`
4. If it is valid, modify [[3. Configuration|config.yml]] and configure the new auto-generated outputs:

```yaml
generation:
  artifacts:
    ...
    - myNewOntology
conversion:
  shacl_to_json:
    ...
    recycling:
      name: "myNewOntology"
      input: "shapes/v0.1/myNewOntology.shacl.ttl"
      output: "build/v0.1/myNewOntology.schema.json"
  json_to_ts:
    ...
    recycling:
      name: "myNewOntology"
      input: "build/v0.1/myNewOntology.schema.json"
      output: "build/v0.1/myNewOntology.ts"
      source: "shapes/v0.1/myNewOntology.shacl.ttl"
  shacl_to_context:
    ...
    recycling:
      name: "Recycling (generated context)"
      input: "shapes/v0.1/recycling.shacl.ttl"
      output: "build/v0.1/recycling.context.jsonld"
```

5. Generate the JSON Context from the Shapes: `npm run convert:context`
6. Generate the JSON Schema from the Shapes: `npm run generate:json-schema`
7. Generate the TypeScript from the JSON Schema: `npm run convert:ts`
8. Create sample data: now copy the contents of the JSON Schema and paste it into this website: [https://json-schema-faker.js.org/](https://json-schema-faker.js.org/)
9. Put the generated content into an RDF file: `examples/v0.1/my-new-ontology-sample.ttl`
   - Remember to correctly set the `@context` and the `@type`
   - In the case of `@context`, to avoid validation issues with contexts that are not published in a public repository, point to the local one:
     - `"@context": "../../build/v0.1/my-new-ontology.context.jsonld",`

10. In [[3. Configuration#9.2 SHACL (`validation.shacl`)|settings]], create the scenario so that it can be validated
11. Run the validator (you can also validate with manual tools: [https://shacl.org/playground/](https://shacl.org/playground/))

- `npm run validate:shacl`
- `npm run validate:shacl <scenario-name>`

12. If errors appear in the previous step, you must adjust them to end up with a valid example.

- The important point here is to think whether the error is in the SHACL or in the RDF; this is a good moment to stop and reason about it.

13. Generate the TypeScript types: `npm run generate:types`
14. Build the Node contracts package: `npm run contracts:build`

- Besides building the package, this also updates the generated typings artifacts defined in `config.yml` (`generation.artifacts`) and the `index.ts` files.

15. If you want to run tests using the validators and typings, go to `examples/consumer-node-ts/src/index.ts`, use the new typings, and write validation tests.
16. Run the tests: `npm run test`
17. Update the wiki: `npm run generate:wiki`

- Review it and check that it is correct in `build/<build_version>/wiki/`.

---

### Workflow 2: Updating Existing Shapes and Ontology

1. Edit the ontology: `vim ontology/v0.1/myOntology.ttl`
2. Validate that the changes do not break syntax: `npm run validate:owl`
3. Edit the SHACL shapes: `vim shapes/v0.1/myOntology.shacl.ttl`
4. Repeat the same steps as in [[#Workflow 1 Creating a New Ontology]] from step 5 onward.

---

### Workflow 3: How to Use the Ontology in JSON-LD Format

> In this case, we do not use the Node package.

The idea and best practice here is to use an existing Shape, for example the one for [recycling](https://blue-room-innovation.github.io/dcasr-ontology/build/v0.1/recycling.context.jsonld). The reason is simple: the work of defining the JSON-LD structure and the assigned semantics has already been done beforehand, so you will not make mistakes. You could also create the `@context` yourself—it is more flexible—but for context (no pun intended).
More information on the topic can be found at [https://niem.github.io/json/reference/json-ld/context/](https://niem.github.io/json/reference/json-ld/context/), section `Linking a JSON file to a JSON-LD context`.

By default, Shapes are closed, meaning we do not allow additional keys beyond those that were designed. Therefore, once the Shape has been defined and the context has been exposed, what is effectively created is the contract you must follow.

1. If you want to transform a JSON into JSON-LD, do the following:
   - Create a dictionary where `@context` points to `https://blue-room-innovation.github.io/dcasr-ontology/build/vX.X/X.context.jsonld`
   - Set `@id` and `@type`
   - Fill in the keys defined by the context

2. If you want to transform a list into JSON-LD, do the following:
   - Create a dictionary where `@context` points to `https://blue-room-innovation.github.io/dcasr-ontology/build/vX.X/X.context.jsonld`
   - Create the list inside the `@graph` key (if it is not a list, then simply do what is described in the previous point)
     - Each element inside this list can assign values based on the ontology; remember to include `@id` and `@type`

3. The result would look something like this, in the case of a list:

```jsonld
{
  "@context": "https://blue-room-innovation.github.io/dcasr-ontology/build/v0.1/recycling.context.jsonld",
  "@graph": [
    {
      "@id": "E-2222.22",
      "@type": "Recycler",
      "managerCode": "E-2222.22",
      "nimaCode": "222222222222",
      "name": "asdf2, SL",
      "streetAddress": "C/ asdf2, 49-51 5",
      "addressLocality": "asdf2",
      "postalCode": "222222",
      "correspondeceAddress": "C/ asdf2, 49-51",
      "correspondeceAddressLocality": "asdf2",
      "correspondecePostalCode": "222222",
      "telephone": "-",
      "faxNumber": "",
      "email": "asdf2@asdf2.com",
      "url": "",
      "adaptedToRD1102015": "",
      "wasteTreatmentActivity": "asdf2"
    }
  ]
}
```

4. Finally, use the [[#Workflow 5 How to Validate a JSON-LD|validator]].
5. Fix any issues that are reported.

---

### Workflow 4: How to Use the Ontology Without JSON-LD

In this case, we do not modify the structure of the JSON to explicitly convert it to JSON-LD. The idea is different: **the JSON remains “normal” JSON**, but we add ontology semantics **from the outside**, using standard mechanisms.

This is useful when:

- You cannot (or do not want to) modify the JSON payload.
- You already have APIs or systems that return fixed JSON.
- You want to add semantics in a transparent and non-intrusive way.

The key concept is that **a JSON can be interpreted as JSON-LD if you associate an external `@context` with it**.
More information:

- [https://www.w3.org/TR/json-ld/#interpreting-json-as-json-ld](https://www.w3.org/TR/json-ld/#interpreting-json-as-json-ld)
- [https://niem.github.io/json/reference/json-ld/context/](https://niem.github.io/json/reference/json-ld/context/) section `### Provide a context in an HTTP Link header`

Steps:

1. Associate the context via an HTTP header
   Instead of adding `@context` inside the document, you publish it at the transport level (HTTP).
   - The server returns a standard JSON
   - In the HTTP response, you add a `Link` header pointing to the context
     Conceptual header example:
     `Link: <https://blue-room-innovation.github.io/dcasr-ontology/build/vX.X/X.context.jsonld>; rel="http://www.w3.org/ns/json-ld#context"; type="application/ld+json"`
   - The response body can be a “plain” JSON, without `@context`, `@id`, or `@type`.

2. The client interprets the JSON as JSON-LD
   A JSON-LD-aware client:
   - Reads the normal JSON
     - Detects the `@context` via the HTTP header
       - Automatically applies the semantics defined in the ontology
         In practice:

   - JSON keys gain RDF meaning
     - `@type`, properties, and relationships can be inferred from the context
       - The original JSON contract has not been altered

3. Contract and validation still apply
   Even if the JSON does not explicitly contain JSON-LD:
   - The **Shape remains the contract**
   - The context defines which keys are valid and what they mean
   - You can still validate against the ontology (SHACL/Shape)
     The difference is **where** you declare the semantics, not **which** semantics you declare.

---

### Workflow 5: How to Validate a JSON-LD

For each JSON-LD, there is a SHAPE and an Example that helps with validation during development.

1. Copy the JSON-LD you want to validate.
2. Find the corresponding example in the `dcasr-ontology` repository and temporarily paste the content there.
3. Then run the validator for the relevant scenario:
   - `npm run validate:shacl <scenario>`

---

### Workflow 4: CI/CD Integration

> TODO
