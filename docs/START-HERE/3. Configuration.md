## Configuration Manual

This repository is **configuration-driven**: the `config.yml` file is the **single source of truth** for deciding **what exists**, **where it lives**, **what is validated**, and **what is generated**.

- All main commands run in Docker (`node docker/docker.js ...`) and **read `config.yml` at runtime**.
- In practice, **changing versions, adding ontologies/shapes, validation scenarios, or generated artifacts is done by editing `config.yml`, not by touching scripts**.
- Paths inside `config.yml` must be **relative to the repository root**.

> [!NOTE] TL;DR
> Using `config.yml`, **all repository behavior is centrally controlled**: active versions of ontologies, shapes, examples, and builds; the base paths where each component lives; the official inventory of ontologies and SHACL; the artifacts to generate (JSON Schema, TypeScript); OWL and SHACL validation scenarios and options; reusable conversions between formats; documentation generation; and versioning and release rules. Any functional change—adding an ontology, bumping a version, defining new validations, generating types, or adjusting documentation—is done by editing this configuration, keeping scripts generic and the workflow reproducible.

---

## 1) Important rules and conventions

### Paths

- Use paths like: `ontology/v0.1/file.ttl` (with `/`).
- Do not use `C:\...` (the container does not know those paths).
- Keep consistency with `paths.*` + `*_version`.

### Versioning

In this repo, versioning is applied by folders, for example.

When you change a version in `config.yml`, the corresponding folder **must exist** in the repository.

### Identifiers (`name`)

In arrays such as `ontologies[]` / `shapes[]` / `generation.artifacts[]` in `config.yml`:

- `name` is an **internal identifier** (no spaces, stable).
- `display_name` is the “pretty” text for documentation.
- Keep `name` consistent across sections (for example, shapes reference ontologies via `ontology: "<name>"`).

---

## 2) `config.yml` structure (mental map)

- `ontology_version`, `shapes_version`, `examples_version`, `codelists_version`, `contexts_version`, `build_version`
- `paths: {...}`
- `repository: {...}`
- `ontologies: [...]`
- `shapes: [...]`
- `generation: {...}`
- `validation: {...}`
- `conversion: {...}`
- `wiki: {...}`
- `release: {...}`

---

## 3) Versions (`*_version`)

They control **which versioned subfolder** is used when discovering files and when writing outputs.

Keys:

- `ontology_version`: version for `paths.ontology`
- `shapes_version`: version for `paths.shapes`
- `examples_version`: version for `paths.examples`
- `codelists_version`: version for `paths.codelists`
- `contexts_version`: version for `paths.contexts`
- `build_version`: version for `paths.build`

Conceptual example: if `paths.ontology = "ontology"` and `ontology_version = "v0.2"`, the system will work in:

- `ontology/v0.2/...`

**When to change it**

- When publishing a new version of ontologies/shapes/examples.
- When you want to generate artifacts in a new build: `build/v0.2`.

**Checklist**

1. Create the folders `ontology/vX`, `shapes/vX`, etc. (if applicable).
2. Copy/update the TTL files.
3. Update the `*_version` values in `config.yml`.
4. Run `npm run build:all` to verify.

---

## 4) Base paths (`paths.*`)

They define **where each component lives** in the repo (without version).

Typical keys:

- `paths.ontology`: base folder for ontologies
- `paths.shapes`: base folder for SHACL
- `paths.examples`: base folder for examples
- `paths.codelists`: base folder for codelists
- `paths.contexts`: base folder for JSON-LD contexts
- `paths.build`: base folder for generated outputs
- `paths.docs`, `paths.scripts`: support

**Best practices**

- Usually **not changed** unless doing a structural refactor.
- If changed, review all referenced paths in `validation.*`, `conversion.*`, `wiki.*`.

---

## 5) Repository (`repository`)

Used to build URLs/refs (for example, for documentation or links to raw files).

Keys:

- `owner`, `name`, `branch`, `base_url`, `pages_url`

`pages_url` is the base URL of the GitHub Pages website. It is used by generators that need to write **absolute** links (for example the build index).

Example:

```yaml
repository:
  pages_url: "https://blue-room-innovation.github.io/dcasr-ontology"
```

**When to change it**

- If the repo is migrated (owner/name change).
- If a different default branch is used.

---

## 6) Ontology inventory (`ontologies[]`)

The “official” list of ontologies considered by the tooling.

Each item:

- `name`: internal id (e.g. `digitalWastePassport`)
- `file`: TTL file name (e.g. `digitalWastePassport.ttl`)
- `display_name`: name for documentation
- `description`: human-readable description

**What it controls**

- Which ontologies are documented.
- Which ontologies are validated/auto-discovered (depending on the command).

**Adding a new ontology**

1. Create the file in `ontology/<ontology_version>/myOntology.ttl`.
2. Add an entry to `ontologies[]`:

```yaml
- name: "myOntology"
  file: "myOntology.ttl"
  display_name: "My Ontology"
  description: "Short description"
```

3. (Recommended) Add associated shapes in `shapes[]` if applicable.
4. Validate: `npm run validate:owl`.

---

## 7) SHACL inventory (`shapes[]`)

The “official” list of SHACL shapes.

Each item:

- `name`: internal id of the shapes package
- `file`: shape TTL
- `ontology`: **reference to `ontologies[].name`** it applies to

**What it controls**

- Which shapes are used in documentation and counts.
- Allows associating shapes to an ontology so the tooling can group them.

**Adding new shapes**

1. Create `shapes/<shapes_version>/myOntologyShapes.ttl`.
2. Add an entry:

```yaml
- name: "myOntology"
  file: "myOntologyShapes.ttl"
  ontology: "myOntology"
```

---

## 8) Generation (`generation`)

Defines which artifacts are generated “in batch” (for example with `npm run generate:types`).

Structure:

- `generation.artifacts[]`: list of packages to process

Each artifact:

- `name`: internal id
- `shape_file`: input SHACL file (usually in `shapes/<shapes_version>/`)
- `json_schema`: expected/generated JSON Schema name
- `typescript`: expected/generated TS name

**What it controls**

- What is processed when running:
  - `npm run generate:types`
  - `npm run generate:types:verbose`

**Adding a new types artifact**

1. Ensure the shape TTL exists in `shapes/<shapes_version>/`.
2. Add to `generation.artifacts[]`:

```yaml
- name: "myOntology"
  shape_file: "myOntologyShapes.ttl"
  json_schema: "myOntology.schema.json"
  typescript: "myOntology.ts"
```

3. Run `npm run generate:types`.
4. Verify output in `build/<build_version>/`.

---

## 9) Validation (`validation`)

### 9.1 OWL (`validation.owl`)

Configures how OWL is validated when running:

- `npm run validate:owl`
- `npm run validate:owl:quiet`
- `npm run validate:owl:with-codelists`

Keys:

- `reasoner`: `"HermiT" | "ELK" | "none"`
- `profile`: `"DL" | "OWL2"`
- `include_codelists`: `true | false`

**How to use it**

- If the repo grows and reasoning becomes heavy, you can change:
  - `reasoner: "none"` (faster, less inference)

- If profile incompatibilities appear:
  - Adjust `profile` (according to project guarantees)

---

### 9.2 SHACL (`validation.shacl`)

Configures SHACL scenarios for:

- Listing: `npm run validate:shacl:list`
- Running validation for all scenarios: `npm run validate:shacl`
- Running a specific scenario: `npm run validate:shacl <scenario-name>`

Keys:

- `scenarios`: map of scenarios

Each scenario:

- `name`: human-readable name
- `description`: human-readable description
- `data`: RDF data file (examples)
- `shapes`: shapes TTL file
- `format`: `"human" | "text" | "turtle" | "json-ld"`
- `extras`: CSV string of extra TTLs or `""`

**Adding a new SHACL scenario**

1. Create/identify `examples/<examples_version>/my-data.ttl`.
2. Create/identify `shapes/<shapes_version>/my-shapes.ttl`.
3. Add scenario:

```yaml
dmwp:
  name: "My Scenario"
  description: "description"
  data: "examples/v0.1/*.ttl"
  shapes: "shapes/v0.1/*.ttl"
  format: "human"
  extras: ""
```

4. Test:
   - `npm run validate:shacl:list`
   - `npm run validate:shacl <scenario-name>`

**Notes on `extras`**

- Useful when the validator needs additional ontologies/codelists to resolve prefixes/classes.
- Format: `"path1.ttl,path2.ttl"` (CSV in a string). If not needed: `""`.

---

## 10) Conversion (`conversion`)

Allows defining named conversions to reuse them in the CLI (especially SHACL → JSON Schema → TS).

Sections:

- `conversion.shacl_to_json`: entries with `input` and `output`
- `conversion.json_to_ts`: entries with `input`, `output`, and `source`

Example of `shacl_to_json.<id>`:

- `input`: shapes TTL
- `output`: build JSON Schema

Example of `json_to_ts.<id>`:

- `input`: JSON Schema
- `output`: TypeScript
- `source`: path to the shapes TTL (for banner/metadata)

**When to change it**

- When you want to **fix specific conversion paths** by id (e.g. `dwp`, `dmwp`) and have the tooling use them consistently.

**Best practices**

- `output` should point to `build/<build_version>/...`
- `input` should point to `shapes/<shapes_version>/...`

---

## 11) Wiki (`wiki`)

Controls documentation generation (`npm run generate:wiki` and variants).

Keys:

- `output_dir`: output folder (default `build/{build_version}/wiki`)
- `include_codelists`: `true | false`
- `formats`: list (e.g. `- markdown`)

Notes:

- `{build_version}` is expanded using the `build_version` value from `config.yml`.

**When to change it**

- Change destination folder (`output_dir`).
- Include/exclude codelists from documentation.

---

## 12) Release (`release`)

Defines versioning and component grouping rules.

Keys:

- `versioning`: semver guideline (descriptive text)
- `independent_components`: components that can version/release independently (e.g. codelists)
- `synchronized_components`: components released together (e.g. `ontology`, `shapes`, `examples`)

**What it controls**

- Usually consumed by release scripts (e.g. `npm run release:version`, `npm run release:all`) to decide strategy and consistency.

---

## 13) Typical workflows (editing only `config.yml`)

### A) Bump version from “v0.1” to “v0.2”

1. Duplicate/create new folders: `ontology/v0.2`, `shapes/v0.2`, `examples/v0.2`, etc.
2. Update in `config.yml`:
   - `ontology_version: "v0.2"`
   - `shapes_version: "v0.2"`
   - `examples_version: "v0.2"`
   - `build_version: "v0.2"`

3. Run:
   - `npm run validate:owl:with-codelists`
   - `npm run generate:all`

### B) Add an ontology and its shapes

1. Add to `ontologies[]`.
2. Add to `shapes[]` linking with `ontology: "<name>"`.
3. (Optional, recommended) Add a SHACL scenario in `validation.shacl.scenarios`.
4. Add an artifact to `generation.artifacts[]` if TS/JSON Schema are needed.
5. Run `npm run build:all`.

---

## 14) Quick checks after editing `config.yml`

- View effective configuration:
  - `npm run config:show`

- List SHACL scenarios:
  - `npm run validate:shacl:list`

- OWL validation:
  - `npm run validate:owl`

- Full pipeline:
  - `npm run build:all`

---

## 15) Common errors (and how to avoid them)

- **Changing `*_version` without creating the corresponding folder** → “file not found” errors.
- **`shapes[].ontology` does not match any `ontologies[].name`** → inconsistent documentation/grouping.
- **Absolute Windows paths** in `data/shapes/extras/input/output` → do not work in Docker.
- **Malformed `extras`** (spaces or separators) → use CSV without breaks: `"a.ttl,b.ttl"`.
