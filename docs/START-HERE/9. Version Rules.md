This note defines **how and when ontologies, shapes, and artifacts can be modified**, and **what must NEVER be touched** once a version is in use.
The goal is to avoid **silent breaking changes**, **unstable URLs**, and **inconsistencies across environments** (dev, staging, production).

---

## Fundamental Principle

> **A released version is immutable.**

Any file within a version that:

- is already in production, or
- is being consumed by third parties, or
- is referenced by public URLs

must **NEVER** be modified in-place.

---

## Why is it critical to respect versioning?

### 1. URL stability

Consumers (APIs, apps, legal documents, auditors, regulators) may reference:

```text
https://.../ontology/v0.1/xxx.ttl
https://.../build/v0.1/xxx.schema.json
```

If the content changes without changing the version:

- Trust is broken
- Existing validations break
- Hard-to-trace bugs are created

---

### 2. Data contracts

JSON Schema and TypeScript **are contracts**, not just technical files.

Changing:

- field names
- cardinalities
- constraints
- enums / codelists

can:

- invalidate existing data
- break APIs
- cause historical imports to fail

---

### 3. Reproducibility and auditability

An auditor must be able to say:

> “This dataset complies exactly with version **v0.1** of the Digital Waste Passport.”

This is **only true** if v0.1 never changes.

---

## What is considered "version-sensitive"?

The following elements **must not be touched** within an existing version:

### Ontologies (OWL)

- Classes
- Properties
- Domains / ranges
- Axioms
- Imports

### SHACL Shapes

- `sh:property`
- `sh:minCount / maxCount`
- `sh:datatype`
- `sh:in`
- `sh:node`

### JSON Schema

- `required`
- `type`
- `enum`
- `format`
- `additionalProperties`

### TypeScript

- Interface names
- Field types
- Optionality

### URLs

- File paths
- JSON-LD contexts
- OWL imports

---

## When do you **NOT** need to create a new version?

You can improve things **without changing the version** only if:

- You fix typos **only in documentation**
- You add comments (`rdfs:comment`, markdown, README)
- You improve human-readable explanations
- You add new examples **without modifying existing ones**

> Golden rule: **if a machine cannot notice it, you don’t need to version it.**

---

## When do you **HAVE** to create a new version?

Always create a new version (`v0.2`, `v1.0`, etc.) if you:

- Add or remove classes
- Add or remove properties
- Change cardinalities
- Tighten SHACL validations
- Modify enums / codelists
- Change semantic meaning
- Change a JSON Schema
- Change generated TypeScript

**Any change that can invalidate existing data requires a new version.**

---

## Recommended Versioning Strategy

### Development

```text
v0.1   → in production (immutable)
v0.2   → in development
```

- `v0.1` **must not be touched**
- All changes go into `v0.2`

---

### Release process

> There is a script that helps you do what is described here, but it is under development, not stable, and for now it is better to do it manually, as I explain here:

1. Copy the folder:

   ```text
   ontology/v0.1 → ontology/v0.2
   shapes/v0.1   → shapes/v0.2
   examples/v0.1 → examples/v0.2
   ```

2. Update versions in the configuration file
3. Apply changes only to the new version
4. Generate new artifacts:

   ```text
   build/v0.2/
   ```

---

## Codelists: Special case

Codelists can:

- have **independent versioning**
- evolve faster

But:

- you must **never change an existing value**
- you may only **add new codes**

If you need to remove something or change its meaning → **new codelist version**

---

## Be strict

Intrusive thoughts you should avoid:

- _It’s just a small change_
  - There are no small changes in data contracts

- _Nobody uses it yet_
  - You can’t guarantee that

- _I’ll change the file but not the name_
  - Silent breaking change

- _I’ll update the example so it validates_
  - You are falsifying history
