import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import YAML from "yaml";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const packageDir = path.resolve(__dirname, "..");
const repoRoot = path.resolve(packageDir, "..", "..");

const verbose =
  process.env.SYNC_ARTIFACTS_VERBOSE !== "0" &&
  process.env.SYNC_ARTIFACTS_VERBOSE !== "false";

function log(...args) {
  if (!verbose) return;
  console.log("[sync-artifacts]", ...args);
}

function generatedHeader(fileLabel) {
  return `/**\n * AUTO-GENERATED by scripts/sync-artifacts.mjs\n * DO NOT EDIT MANUALLY\n * Output: ${fileLabel}\n */\n\n`;
}

async function exists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

function toSchemaKey(artifactName) {
  return artifactName;
}

function parseRootNameFromJsonSchema(schemaSource) {
  try {
    const parsed = JSON.parse(schemaSource);
    if (parsed && typeof parsed.title === "string" && parsed.title.length > 0) {
      return parsed.title;
    }
  } catch {
    // ignore
  }
  return null;
}

function parseRootExportName(tsSource) {
  // json-schema-to-typescript may emit either:
  // - export interface RootName { ... }
  // - export type RootName = A & B (common when schema has allOf)
  const typeMatch = /export\s+type\s+([A-Za-z0-9_]+)\s*=/.exec(tsSource);
  if (typeMatch) return typeMatch[1];

  const ifaceMatch = /export\s+interface\s+([A-Za-z0-9_]+)/.exec(tsSource);
  if (ifaceMatch) return ifaceMatch[1];

  return null;
}

function parseBuildVersionTag(buildVersion) {
  const match = /^v(\d+)\.(\d+)$/.exec(buildVersion);
  if (!match) {
    throw new Error(
      `Unsupported build_version format: ${buildVersion}. Expected like v0.1`,
    );
  }
  const major = match[1];
  const minor = match[2];
  return `V${major}${minor}`;
}

const configPath = path.join(repoRoot, "config.yml");
if (!(await exists(configPath))) {
  throw new Error(`Missing config.yml at ${configPath}`);
}

log("repoRoot:", repoRoot);
log("packageDir:", packageDir);
log("config:", configPath);

const configRaw = await fs.readFile(configPath, "utf8");
const config = YAML.parse(configRaw);

const buildVersion = config?.build_version;
const artifactsCfg = config?.generation?.artifacts;

log("build_version:", buildVersion);
log("generation.artifacts:", artifactsCfg);

if (typeof buildVersion !== "string" || buildVersion.length === 0) {
  throw new Error(
    `config.yml must define build_version (string). Got: ${String(buildVersion)}`,
  );
}

if (!Array.isArray(artifactsCfg) || artifactsCfg.length === 0) {
  throw new Error(
    "config.yml must define generation.artifacts as a non-empty list",
  );
}

if (!artifactsCfg.every((a) => typeof a === "string" && a.length > 0)) {
  throw new Error(
    "config.yml generation.artifacts must be a list of non-empty strings (artifact ids)",
  );
}

const buildDir = path.join(repoRoot, "build", buildVersion);
if (!(await exists(buildDir))) {
  throw new Error(
    `Missing build output directory: ${buildDir}. Generate artifacts first (e.g. npm run generate:types).`,
  );
}

log("buildDir:", buildDir);

const schemasDestDirCurrent = path.join(packageDir, "schemas", "current");
const generatedDestDirCurrent = path.join(
  packageDir,
  "src",
  "generated",
  "current",
);
const currentIndexDir = path.join(packageDir, "src", "current");

const versionedIndexDir = path.join(packageDir, "src", buildVersion);

const schemasDestDirVersioned = path.join(packageDir, "schemas", buildVersion);
const generatedDestDirVersioned = path.join(
  packageDir,
  "src",
  "generated",
  buildVersion,
);

await fs.mkdir(schemasDestDirCurrent, { recursive: true });
await fs.mkdir(generatedDestDirCurrent, { recursive: true });
await fs.mkdir(currentIndexDir, { recursive: true });
await fs.mkdir(versionedIndexDir, { recursive: true });
await fs.mkdir(schemasDestDirVersioned, { recursive: true });
await fs.mkdir(generatedDestDirVersioned, { recursive: true });

log("schemasDestDirCurrent:", schemasDestDirCurrent);
log("generatedDestDirCurrent:", generatedDestDirCurrent);
log("currentIndexDir:", currentIndexDir);
log("versionedIndexDir:", versionedIndexDir);
log("schemasDestDirVersioned:", schemasDestDirVersioned);
log("generatedDestDirVersioned:", generatedDestDirVersioned);

function baseName(p) {
  if (typeof p !== "string") return null;
  return path.basename(p);
}

function resolveArtifactItem(a) {
  const name = a;
  if (typeof name !== "string" || name.length === 0) return null;

  // Minimal form: derive from conversion config
  const shaclScenario = config?.conversion?.shacl_to_json?.[name];
  const tsScenario = config?.conversion?.json_to_ts?.[name];

  const schemaOut = baseName(shaclScenario?.output);
  const tsOut = baseName(tsScenario?.output);

  if (!schemaOut || !tsOut) return null;
  return { name, json_schema: schemaOut, typescript: tsOut };
}

const items = artifactsCfg
  .map(resolveArtifactItem)
  .filter(
    (a) =>
      a &&
      typeof a.name === "string" &&
      typeof a.json_schema === "string" &&
      typeof a.typescript === "string",
  );

if (items.length === 0) {
  throw new Error(
    "generation.artifacts in config.yml has no valid items. Ensure each id exists in conversion.shacl_to_json and conversion.json_to_ts and that both specify an output filename.",
  );
}

const schemaEntries = [];
const typeEntries = [];

for (const item of items) {
  const schemaKey = toSchemaKey(item.name);

  log("artifact:", item.name);
  log("  schemaKey:", schemaKey);

  const schemaSrc = path.join(buildDir, item.json_schema);
  const tsSrc = path.join(buildDir, item.typescript);

  if (!(await exists(schemaSrc))) {
    throw new Error(`Missing schema artifact: ${schemaSrc}`);
  }
  if (!(await exists(tsSrc))) {
    throw new Error(`Missing TypeScript artifact: ${tsSrc}`);
  }

  const schemaDestCurrent = path.join(schemasDestDirCurrent, item.json_schema);
  const tsDestCurrent = path.join(generatedDestDirCurrent, item.typescript);

  const schemaDestVersioned = path.join(
    schemasDestDirVersioned,
    item.json_schema,
  );
  const tsDestVersioned = path.join(generatedDestDirVersioned, item.typescript);

  await fs.copyFile(schemaSrc, schemaDestCurrent);
  await fs.copyFile(tsSrc, tsDestCurrent);

  log("  copy schema ->", schemaDestCurrent);
  log("  copy types  ->", tsDestCurrent);

  // Keep versioned copies too (for optional versioned exports)
  await fs.copyFile(schemaSrc, schemaDestVersioned);
  await fs.copyFile(tsSrc, tsDestVersioned);

  log("  copy schema (versioned) ->", schemaDestVersioned);
  log("  copy types  (versioned) ->", tsDestVersioned);

  const schemaSource = await fs.readFile(schemaSrc, "utf8");
  const tsSource = await fs.readFile(tsSrc, "utf8");

  // Prefer JSON Schema root title (deterministic). Fallback to parsing TS exports.
  const rootExport =
    parseRootNameFromJsonSchema(schemaSource) ?? parseRootExportName(tsSource);

  if (!rootExport) {
    throw new Error(
      `Could not detect root exported type/interface in ${tsSrc} (and no schema title in ${schemaSrc})`,
    );
  }

  log("  rootExport:", rootExport);

  schemaEntries.push({ schemaKey, json_schema: item.json_schema });
  typeEntries.push({
    schemaKey,
    typescript: item.typescript,
    rootInterface: rootExport,
  });
}

// Generate src/current/index.ts (typed schema keys + type map)
const currentIndexPath = path.join(currentIndexDir, "index.ts");

const exportTypes = typeEntries
  .map(
    (t) =>
      `export type { ${t.rootInterface} } from "../generated/current/${t.typescript.replace(/\.ts$/, ".js")}";`,
  )
  .join("\n");

const schemaKeyUnion =
  schemaEntries.map((s) => JSON.stringify(s.schemaKey)).join(" | ") || "never";

const typeMapLines = typeEntries
  .map(
    (t) =>
      `  ${JSON.stringify(t.schemaKey)}: import("../generated/current/${t.typescript.replace(/\.ts$/, ".js")}").${t.rootInterface};`,
  )
  .join("\n");

const currentIndexSource = `${generatedHeader("src/current/index.ts")}${exportTypes}

export const CURRENT_BUILD_VERSION = ${JSON.stringify(buildVersion)} as const;

export type SchemaKeyCurrent = ${schemaKeyUnion};

export interface SchemaTypeMapCurrent {
${typeMapLines}
}

export type SchemaTypeCurrent<K extends SchemaKeyCurrent> = SchemaTypeMapCurrent[K];
`;

await fs.writeFile(currentIndexPath, currentIndexSource, "utf8");
log("generated:", currentIndexPath);

// Generate src/<buildVersion>/index.ts (typed schema keys + type map)
// This keeps the versioned export (e.g. "./v0.1") fully in sync with generated artifacts.
const versionTag = parseBuildVersionTag(buildVersion);
const versionedIndexPath = path.join(versionedIndexDir, "index.ts");

const versionedExportTypes = typeEntries
  .map(
    (t) =>
      `export type { ${t.rootInterface} } from "../generated/${buildVersion}/${t.typescript.replace(/\.ts$/, ".js")}";`,
  )
  .join("\n");

const versionedSchemaKeyUnion =
  schemaEntries.map((s) => JSON.stringify(s.schemaKey)).join(" | ") || "never";

const versionedTypeMapLines = typeEntries
  .map(
    (t) =>
      `  ${JSON.stringify(t.schemaKey)}: import("../generated/${buildVersion}/${t.typescript.replace(/\.ts$/, ".js")}").${t.rootInterface};`,
  )
  .join("\n");

const versionedIndexSource = `${generatedHeader(`src/${buildVersion}/index.ts`)}${versionedExportTypes}

export type SchemaKey${versionTag} = ${versionedSchemaKeyUnion};

export interface SchemaTypeMap${versionTag} {
${versionedTypeMapLines}
}

export type SchemaType${versionTag}<K extends SchemaKey${versionTag}> = SchemaTypeMap${versionTag}[K];
`;

await fs.writeFile(versionedIndexPath, versionedIndexSource, "utf8");
log("generated:", versionedIndexPath);

// Generate src/index.ts (public API surface)
// Keep this file generated so exports never drift when root interface names change.
const rootIndexPath = path.join(packageDir, "src", "index.ts");
const versionedExportTypeNames = typeEntries
  .map((t) => t.rootInterface)
  .sort((a, b) => a.localeCompare(b));

const rootIndexSource = `${generatedHeader("src/index.ts")}export { createValidator } from "./validator.js";
export type {
  AjvInstance,
  CreateValidatorOptions,
  SchemaVersion,
  SchemaKey,
  ValidationError,
  ValidateResult,
  OntologyValidator
} from "./validator.js";

export type {
  SchemaKeyCurrent,
  SchemaTypeMapCurrent,
  SchemaTypeCurrent
} from "./current/index.js";

export type {
  SchemaKey${versionTag},
  SchemaTypeMap${versionTag},
  SchemaType${versionTag},
  ${versionedExportTypeNames.join(",\n  ")}
} from "./${buildVersion}/index.js";
`;

await fs.writeFile(rootIndexPath, rootIndexSource, "utf8");
log("generated:", rootIndexPath);

// Generate src/schema-registry.ts (runtime schema URL map)
const registryPath = path.join(packageDir, "src", "schema-registry.ts");
const registryEntries = schemaEntries
  .map(
    (s) =>
      `  ${JSON.stringify(s.schemaKey)}: new URL("../schemas/current/${s.json_schema}", import.meta.url),`,
  )
  .join("\n");

const registrySource = `import type { SchemaKeyCurrent } from "./current/index.js";

export const schemaUrlsCurrent: Record<SchemaKeyCurrent, URL> = {
${registryEntries}
};
`;

await fs.writeFile(registryPath, registrySource, "utf8");
log("generated:", registryPath);

console.log(
  `ontology-contracts: synced artifacts from build/${buildVersion} (config-driven) and generated current typings`,
);
